\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename manual.info
@include version.texi
@settitle The GNU Taler manual for Merchants@value{VERSION}

@c Define a new index for options.
@defcodeindex op
@c Combine everything into one index (arbitrarily chosen to be the
@c concept index).
@syncodeindex op cp
@c %**end of header

@copying
This manual is for GNU Taler merchant backend (version @value{VERSION}, @value{UPDATED}),

Copyright @copyright{} 2016 INRIA

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
@end quotation
@end copying
@c If your manual is published on paper by the FSF, it should include
@c The standard FSF Front-Cover and Back-Cover Texts, as given in
@c maintain.texi.
@c
@c Titlepage
@c
@titlepage
@title The GNU Taler manual for Merchants
@subtitle Version @value{VERSION}
@subtitle @value{UPDATED}
@author Marcello Stanisci (@email{marcello.stanisci@@inria.fr})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@summarycontents
@contents

@ifnottex
@node Top
@top The GNU libmicrohttpd Library
@insertcopying
@end ifnottex

@menu
* introduction::	Whom this manual is addressed to	
* dependencies::	Needed libraries to build the backend
* installation::        Installing the Merchant backend
* configuration::       How to set up the Merchant backend
* hello-world::         How to set up a minimalistic shop
@end menu

@node introduction
@chapter Whom this manual is addressed to
This manual is addressed to people who want to integrate Taler
in their online shop. The goal is to install a Taler @emph{backend} and
make it communicate with their existing shop (the @emph{frontend}).
In Taler terminology, the backend is the component that provides RESTful
API to the frontend and that will do all crypto work and communication
with the Taler exchange. In other words, the frontend will never directly
communicate with the exchange. It is strongly recommended to read the official
documentation@footnote{@*https://api.taler.net@*https://taler.net} beforehand,
especially before reading @xref{hello-world}.

@node dependencies
@chapter Needed libraries to build the backend

The following packages need to be installed, in order to provide the
backend all the libraries it depends on.

@itemize
@item GNUnet
@item Taler Exchange
@item libmicrohttpd
@item libjansson
@item libcurl
@item libpq
@end itemize

@section Installing GNUnet
GNUnet provides the backend all the routines for doing: cryptography,
string manupulation, interfacing with DB, non-Taler specific JSON manupulation,
logging, operating system interfacing.

Downloading GNUnet:

@code{wget https://gnunet.org/gnunet0-10-1}

Provide the following dependencies:
@itemize
@item @code{libpq} for interfacing with the Postgresql database
@item libgcrypt
@item libjansson
@item libunistring
@item libcurl
@end itemize

Then configure GNUnet as follows:

@example

# From GNUnet's top directory.
$ ./bootstrap
$ ./configure [--prefix=PFX] \
               --without-idn \
               --wit-zlib=no \
               --disable-nls \
               [--with-...]
$ # Each dependency can be fetched from non standard locations via
$ # the '--with-<LIBNAME>' option. See './configure --help'.
$ make
$ make install

@end example

@section Installing The Exchange

Get the latest code:
@code{git clone git://taler.net/exchange}

Provide the following dependencies:
@itemize
@item @code{libpq} for interfacing with the Postgresql database
@item libjansson
@item libmicrohttpd
@item GNUnet
@end itemize

Then configure the exchange as follows:

@example
$ # From exchange's top directory
$ ./bootstrap
$ ./configure [--prefix=PFX] \
              [--with-gnunet=GNUNETPFX] \
              [--with-...]
$ # Each dependency can be fetched from non standard locations via
$ # the '--with-<LIBNAME>' option. See './configure --help'.
$ make
$ make install
@end example

@node installation
@chapter Installing the Merchant backend

The following steps assumes all dependencies are installed. @xref{dependencies}.

Get the code: @code{git clone git://taler.net/merchant}. Configure and install
as follows:

@example
$ # From merchant's top directory
$ ./bootstrap
$ ./configure [--prefix=PFX] \
              [--with-gnunet=GNUNETPFX] \
              [--with-exchange=GNUNETPFX] \
              [--with-...]
$ # Each dependency can be fetched from non standard locations via
$ # the '--with-<LIBNAME>' option. See './configure --help'.
$ make
$ make install
@end example

@node configuration
@chapter How to set up the Merchant backend
The installation already provides reasonable defaults for some of the
configuration options, but some of them must be tuned to the particular case.
The file @code{$HOME/.config/taler.conf} is responsible to ovveride the defaults.

What needs to be tuned:
@itemize
@item Serving
@item Currency
@item Database
@item Exchanges
@item Wireformat
@item Instances
@end itemize

In the following table, the notation @code{[secion]/option} denotes the option
@code{option} under the section @code{[section]} in the configuration file.
@table @asis

@item Serving
The following option sets the transport layer used by the Merchant backend:

@example
[merchant]/serve = TCP | UNIX
@end example

If given,
@itemize
@item @code{TCP}, then we need to set the port in @code{[merchant]/port}
@item @code{UNIX}, then we need to set the unix socket path and mode in
@code{[merchant]/unixpath} and @code{[merchant]/unixpath_mode}. The last takes
the usual permission mask give as number, like 660.
@end itemize
The frontend and backend will then speak HTTP over the chosen serving option.

@item Currency
Instructs the backend on the currency to work with. Set the option:

@example
[merchant]/currency
@end example

@item Database
By design, it is possible to work with different DBMSs, so the Merchant
backend needs to know which one is going to be used. Set this option in:

@example
[merchant]/db
@end example

currently only the value "postgres" is supported.

After configuring the DBMS, we need to instruct the Merchant backend on how the
database is named. Set the option:

@example
[merchantdb-DBMS]/config
@end example

this option needs to comply with the format "DBMS:///dbname", where "dbname" is
the actual database name under DBMS. Note that DBMS must match what it's given in
@code{[merchant]/db}.

@item Exchange
In order to add an exchange to the list of trusted ones, set the options:

@example
[merchant-exchange-myexchange]/uri
@end example

Takes the exchanges base URL, e.g. @code{https://exchange.test.taler.net/}

@example
[merchant-exchange-myexchange]/master_key
@end example

Takes the base32 encoding of the exchanges master key.

Note that multiple exchanges can be added to the system, just by using different
tokens in place of @code{myexchange} above.

@item Wireformat
In order to receive money, the merchant backend needs to tell its bank
details to the exchange. Set the option:

@example
[merchant]/wireformat
@end example

Currently, only the value @code{test} can be given. A wireformat of type @code{SEPA}
will be supported in the future.

@item Instances
In Taler terminology, the Merchant backend allows the user to define
different @i{instances}. An instance can be viewd as a "business entity": something
that can receive money and sign contracts. To that purpose, any instance must
provide its private key and wire details. It is mandatory to provide the "default"
instance, with:

@example
[merchant-instance-default]/keyfile
@end example

Provide here the path to the instance's private key.

@example
[merchant-instance-wireformat-default]/test_response_file
@end example

Provide here the path to the file in JSON format that describes
the instance's wire details. This JSON file must be in the format
given to the option @code{[merchant]/wireformat}. Below there is
an example of a @code{test} wire format file:

@verbatim
{
  "type": "test",
  "bank_uri": "https://bank.test.taler.net/",
  "sig": "MERCHANTSIGNATURE",
  "account_number": 5,
  "salt": "RANDOMSALT"
}
@end verbatim

Note that multiple instances can be added to the Merchant backend just by
using different tokens in place of @code{default}

@end table

@node hello-world
@chapter How to set up a minimalistic shop

In this section, we set up a minimalistic shop, which exposes a
button to get donations via Taler. The expected behaviour is that
once the button is clicked, the customer will either receive a Taler
contract, if they have the wallet installed, or be prompted with a
classic paywall for credit cards. In Taler parlance, the shop (and clearly
the donation button) is the @emph{frontend}.

@section How to trigger Taler payment
The goal is to trigger a Taler payment once the customer has clicked
on the donation button. The triggering happens when the frontend requests
a @emph{contract} to the Merchant backend. According to the API
@footnote{https://api.taler.net}, the backend generates contracts by
serving HTTP requests addressed to @code{/contract}. So our button's goal
is to trigger some server-side logic that will, in the end, issue a HTTP POST
to the backend's @code{/contract}.
Let's say the button will always donate 1 KUDOS to the 'Taler charity program',
its HTML would be as follows:

@example
<form action="/donate">
  <input type="submit" value="Donate!"></input>
<form>
@end example

Namely, its work is merely invoking server-side logic.

Note that we @emph{could} have bypassed the server-side logic to request
the contract to the backend, and have requested it directly from the button's
JavaScript. However, this is highly unpractical because the backend needs
lots of information in the request's body, and we would end up hardcoding
all that information in the JavaScript.

When the server-side handler for @code{/donate} receives the form submission,
it will return a HTML page that will take care of:

@itemize
@item showing a credit card paywall to the user, if no wallet is found.
@item triggering contract generation (in JavaScript) to server-side logic.
@end itemize

A minimalistic @code{/donate} handler is shown below (in PHP):

@display
echo("fallback.html");
@end display

In practical terms, all the logic to detect the wallet in the browser and
request the contract lies in @code{fallback.html}. Moreover, the frontend
developer can get help by the @code{taler-wallet-lib.js} library, which
abstracts the signaling between the HTML page and the wallet. Let's see
below how @code{fallback.html} looks like:

@display
<html>
  <head>
    <script src="taler-wallet-lib.js" type="application/javascript"></script>
    <script type="application/javascript">

      /* This function will be called whenever the wallet signals its presence.
      It then will use the library's function taler.offerContractFrom to
      request the contract to the server-side logic. Finally, taler.offerContractFrom
      will hand the contrat to the wallet once it gets it. */
      function onWalletPresent()@{
        contract_url = "/generate-contract";
        taler.offerContractFrom(contract_url);
      @}
    /* The 'taler' object is exported by the library above */
    taler.onPresent(onWalletPresent);
    </script>
  </head>
  <body>
    <!-- Put the credit card paywall here -->
  </body>
@end display

The result is that if a wallet is found, then the contract is requested so
the user doesn't see the credit card paywall@footnote{In this simple
implementation, the user will se the paywall as long as no contract is received.
Nevertheless, it is easy to temporarily hide the paywall by using the
@code{taler.onAbsent} handler}, otherwise the page rests untouched and the
paywall remains shown.

Now, it's the server-side handler for @code{/generate-contract} that continues.
It has to generate a contract proposal about donating 1 KUDOS to the 'Taler charity program'.
This proposal will then be POSTed to the backend at @code{/contract}@footnote{We assume that
frontend and backend are reachable at the same host}. The main goal of POSTing the proposal
to the backend is to get it signed, as by design the frontend does not perform any
cryptographic work.

Let's see how @code{/generate-contract} handler should look like:

@display
...

# this variable is the JSON of a contract proposal,
# see https://api.taler.net/api-merchant.html#post--contract
$proposal = make_contract("1 KUDOS");

# Here the frontend POSTs the proposal to the backend
$response = post_to_backend("/contract", $proposal);

if(200 != $response->status_code)@{
  manage_error($response);
  return;
@}
echo $response->body;
@end display

As said, @code{taler.offerContractFrom} will hand the contract to the wallet,
which then will prompt the user a formatted version of it.

The next step for the frontend is to accept the payment from the wallet,
whenever the user will accept the contract. In Taler terminology, this action
is managed by two pages: the @emph{fulfillment} and @emph{pay} page.

By design, Taler payments @emph{can} be implemented in DB-less frontends, so the
frontend needs a way to recall basic informations about a contract (e.g. which product,
which price, the timestamp, etc.) before proceeding with the actual payment.
That is achieved by @emph{reconstructing} the contract using the fulfillment page's
parameters@footnote{the fulfillment URL equipped with all the parameters is included
in the contract}.

@section Backend configuration

@subsection Wireformat

Let's say that all the donations go to the following recipient,
expressed in @code{SEPA} format@footnote{As said, supporting SEPA is still
work in progress}.

@verbatim
{
  "type": "SEPA",
  "IBAN": "XY00 1111 2222 3333 4444 5555 6666",
  "name": "Taler charity program",
  "BIC": "XXXXAB99",
  "salt": "RANDOMSALT"
}

@end verbatim

Assume this information is stored in file @code{$DATADIR/sepa.json}.

@subsection Serving

The backend will be listening on port 9898 on the host @code{example.taler.net}

@subsection Key

The backend's key lies at @code{$DATADIR/key.priv}

@subsection Database

The backend will use a database named @code{donations} within Postgresql.

@subsection Exchange

The backend will deposit the coins it receives to the exchange at
@code{https://exchange.demo.taler.net/}, having the master key
"EXAMPLEMASTERKEY".

@subsection Final configuration

The following configuration will drive the Merchant backend to
realize what we planned in the subsections above. We assume the file
@code{$HOME/.config/taler.conf} is being edited. It is the default
file looked by the Merchant backend, but we can pass it config
files from other locations using the @code{-c} option.


@example

[merchant]
wireformat = SEPA
serve = TCP
port = 9898
currency = EUR
database = postgres

[merchant-instance-default]
KEYFILE = $DATADIR/key.priv

[merchant-instance-wireformat-default]
SEPA_RESPONSE_FILE = $DATADIR/sepa.json

[merchantdb-postgres]
config = postgres:///donations

[merchant-demoexchange]
uri = https://exchange.demo.taler.net/
master_key = EXAMPLEMASTERKEY

@end example

The sysadmin should make sure that a database named @code{donations} is
defined and accessible in the system. Once this configuration is ready,
it suffices to run the Merchant backend with:

@example
taler-merchant-httpd
@end example

If everything worked as expected, the following command:
@example
$ curl http://example.taler.net/
@end example

should return the following message:

@example
Hello, I'm a merchant's Taler backend. This HTTP server is not for humans.
@end example



@bye
