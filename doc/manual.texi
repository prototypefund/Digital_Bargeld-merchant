\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename manual.info
@include version.texi
@settitle The GNU Taler manual for Web shop operators{VERSION}

@c Define a new index for options.
@defcodeindex op
@c Combine everything into one index (arbitrarily chosen to be the
@c concept index).
@syncodeindex op cp
@c %**end of header

@copying
This manual is for the GNU Taler merchant backend (version @value{VERSION}, @value{UPDATED}),

Copyright @copyright{} 2016 INRIA

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
@end quotation
@end copying
@c If your manual is published on paper by the FSF, it should include
@c The standard FSF Front-Cover and Back-Cover Texts, as given in
@c maintain.texi.
@c
@c Titlepage
@c
@titlepage
@title The GNU Taler manual for Web shops
@subtitle Version @value{VERSION}
@subtitle @value{UPDATED}
@author Marcello Stanisci (@email{marcello.stanisci@@inria.fr})
@author Christian Grothoff (@email{christian.grothoff.fr})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@summarycontents
@contents

@ifnottex
@node Top
@top The GNU Taler manual for Web shops
@insertcopying
@end ifnottex

@menu
* Introduction::	Whom this manual is addressed to	
* Installation::        Installing the Merchant backend
* Configuration::       How to set up the Merchant backend
* Hello-world::         How to set up a minimalistic shop
@end menu

@node Introduction
@chapter Whom this manual is addressed to

This manual addresses how to integrate GNU Taler with Web shops.  It
describes how to install a GNU Taler merchant @emph{backend} and make it
communicate with an existing Web shop @emph{frontend}.  The backend
provides the cryptographic support, stores Taler-specific financial
information and communicates with the GNU Taler exchange. The frontend
accesses the backend via a RESTful API.  As a result, the frontend
never has to directly communicate with the exchange, and also does not
deal with sensitive data (such as the merchant's signing keys and bank
account information).

@node Installation
@chapter Installation

This chapter describes how to install the GNU Taler merchant backend.

@node Generic instructions
@section Generic instructions

This section provides generic instructions for the merchant
backend installation independent of any particular operating system.
Operating system specific instructions are provided in the following
sections.  You should follow the operating system specific
instructions if those are available, and only consult the generic
instructions if no system-specific instructions are provided for your
specific operating system.

@node Dependencies
@subsection Installation of dependencies

The following packages need to be installed before we can compile the 
backend:

@itemize
@item libcurl or libgnurl
@item GNU libmicrohttpd, including GnuTLS
@item GNU libgcrypt
@item libjansson
@item Postgres, including libpq
@item GNUnet
@item GNU Taler exchange
@end itemize

The first five are available in most GNU/Linux distributions and should
just be installed using the respective package manager, for example
using

@example
# apt-get install libcurl4-gnutls-dev \
  libmicrohttpd-dev \
  libgnutls-dev \
  libgcrypt20-dev \
  libjansson-dev \
  libpq-dev \
  postgresql-9.5 
@end example

The following sections will provide detailed instructions for
installing the GNUnet and GNU Taler exchange dependencies.  


@subsection Installing GNUnet

Note that a Web shop supporting GNU Taler does not actually need to run a
GNUnet peer.  The requirement to have a minimal GNUnet installation
arises from the fact that GNUnet provides some required routines for
doing cryptography, string manupulation, interfacing with databases,
JSON manipulation, logging and operating system abstractions.  Hence
this manual does not describe how to actually run a GNUnet peer, and
we also skip optional GNUnet dependencies that an ordinary peer might
want to include in the installation.  Thus, do not be alarmed if the
GNUnet build process warns you about missing (optional) dependencies.

Before you install GNUnet, you should download and install the
dependencies mentioned in the previous section, otherwise GNUnet may
install but fail to export some of the tooling required by Taler.

To download and install GNUnet, proceed as follows:

@example
$ svn checkout https://gnunet.org/svn/gnunet/
$ cd gnunet/
$ ./bootstrap
$ ./configure [--prefix=GNUNETPFX]
$ # Each dependency can be fetched from non standard locations via
$ # the '--with-<LIBNAME>' option. See './configure --help'.
$ make
# make install
@end example

If you did not specify a prefix, GNUnet will install to
@code{/usr/local}, which requires you to run the last step as
@code{root}.

@subsection Installing the GNU Taler exchange

After installing GNUnet, you can download and install
the exchange as follows:

@example
$ git clone git://taler.net/exchange
$ cd exchange
$ ./bootstrap
$ ./configure [--prefix=EXCHANGEPFX] \
              [--with-gnunet=GNUNETPFX] 
$ # Each dependency can be fetched from non standard locations via
$ # the '--with-<LIBNAME>' option. See './configure --help'.
$ make
# make install
@end example

If you did not specify a prefix, the exchange will install to
@code{/usr/local}, which requires you to run the last step as
@code{root}.  Note that you have to specify
@code{--with-gnunet=/usr/local} if you installed GNUnet to
@code{/usr/local} in the previous step.


@subsection Installing the GNU Taler merchant backend

The following steps assume all dependencies are installed. @xref{dependencies}.

Use the following commands to download and install the
merchant backend:

@example
$ git clone git://taler.net/merchant
$ cd merchant
$ ./bootstrap
$ ./configure [--prefix=PFX] \
              [--with-gnunet=GNUNETPFX] \
              [--with-exchange=EXCHANGEPFX] 
$ # Each dependency can be fetched from non standard locations via
$ # the '--with-<LIBNAME>' option. See './configure --help'.
$ make
$ make install
@end example

Note that you have to specify @code{--with-exchange=/usr/local} if you
installed the exchange to @code{/usr/local} in the previous
step.


@node Configuration
@chapter How to configure the Merchant backend

The installation already provides reasonable defaults for most of the
configuration options. However, some of them must be tuned to the
particular Web shop.  By default, the file
@code{$HOME/.config/taler.conf} is where the Web shop administrator
specifies configuration values that augment or override the defaults.

The following table describes the options that commonly need to be modified.
Here, the notation @code{[section]/option} denotes the option
@code{option} under the section @code{[section]} in the configuration file.

@table @asis

@item Service address
The following option sets the transport layer address used by the Merchant backend:

@example
[merchant]/serve = TCP | UNIX
@end example

If given,
@itemize
@item @code{TCP}, then we need to set the TCP port in @code{[merchant]/port}
@item @code{UNIX}, then we need to set the unix domain socket path and mode in
@code{[merchant]/unixpath} and @code{[merchant]/unixpath_mode}. The latter takes
the usual permission mask given as a number, e.g. 660 for user/group read-write access.
@end itemize

The frontend can then connect to the backend over HTTP using the specified address.
If frontend and backend run within the same operating system, the use of
a UNIX domain socket is recommended to avoid accidentally exposing the backend
to the network.

@c FIXME: we should offer an option to bind the TCP socket to a particular IP address (#4752)

@item Currency
Which currency the Web shop deals in, i.e. ``EUR'' or ``USD'', is specified using the option

@example
[merchant]/currency
@end example

For testing purposes, the currency should match ``KUDOS'' which is used by the Taler
demonstration exchange at @url{https://exchange.demo.taler.net/}.

@item Database
In principle is possible for the backend to support different DBMSs.
The option

@example
[merchant]/db
@end example

specifies which DBMS is to be used. However, currently only the value "postgres" is supported.

In addition to selecting the DBMS software, the backend requires DBMS-specific options to access the database.

For postgres, you need to provide:

@example
[merchantdb-postgres]/config
@end example

This option specifies a postgres access path using the format
"postgres:///DBNAME", where DBNAME is the name of the Postgres
database you want to use.  Suppose USER is the name of the
user who will run the backend process.  Then, you need to first run

@example
$ createuser -d USER
@end example

as the @code{postgres} database administrator to grant USER
the ability to create new databases.  Next, you should as
USER run

@example
$ createdb DBNAME
@end example

to create the backend's database.  Here, DBNAME must match the database name
given in the configuration file.

@item Exchange
To add an exchange to the list of trusted payment service providers,
you create a section with a name that starts with ``merchant-exchange-''
and set the following options in that section:

@example
[merchant-exchange-MYEXCHANGE]/uri
@end example

Takes the exchanges base URL, e.g. @url{https://exchange.demo.taler.net/}.

@example
[merchant-exchange-MYEXCHANGE]/master_key
@end example

Takes the base32 encoding of the exchange's master public key.

Note that multiple exchanges can be added to the system by using different
tokens in place of @code{MYEXCHANGE} in the example above.

@c FIXME: We should provide the master public key of the demo exchange here!

@c FIXME: In the future, we need to describe specifying auditors here.

@item Wireformat

In order to receive payments, the merchant backend needs to communicate bank
account details to the exchange.  This banking system used is specified using the
following global option:

@example
[merchant]/wireformat
@end example

The value @code{test} can be used to interact with the Taler
demonstrator at @url{https://bank.demo.taler.net/}.  Other wireformats
will be supported in the future to interact with actual banks.


@item Instances

The backend allows the user to run multiple instances of shops with
distinct business entities against a single backend.  Each instance
uses its own bank account and key for signing contracts.  It is
mandatory to configure a "default" instance using the following
options:

@example
[merchant-instance-default]/keyfile
@end example

Specifies the path to the instance's private key.  You do not need to
create a key at this time, the backend will generate it automatically
if it is missing.  While generally unnecessary, it is possible to
generate the key and to display the public key using the
@code{gnunet-ecc} command-line tool.

@example
[merchant-instance-wireformat-default]/test_response_file
@end example

This option specifies the path to a file that describes the instance's
wire details in JSON format.  The specific format depends slightly
on the banking system selected via the @code{wireformat} option.

For the @code{test} wire format, a sample specification looks as follows:

@verbatim
{
  "type": "test",
  "bank_uri": "https://bank.test.taler.net/",
  "sig": "MERCHANTSIGNATURE",
  "account_number": 5,
  "salt": "RANDOMSALT"
}
@end verbatim

@c FIXME: is ``sig'' required here? This is odd.  If so, describe
@c how to generate it.  Also explain RANDOMSALT.

@c FIXME: We should provide instructions for how to get an account
@c number for the demo bank!


Note that additional instances can be specified using different tokens
in the section name instead of @code{default}.

@end table


@node Hello-world
@chapter Setting up a simple Web shop with GNU Taler

This section describes how to setup a simple shop, which exposes a
button to get donations via Taler. The expected behaviour is that once
the ``donate'' button is clicked, the customer will receive a Taler
contract offering him the opportunity to make a fixed donation,
for example to donate 1 KUDOS to the charity operating the shop.

Note that if the customer does not have the Taler wallet installed,
they should instead be prompted to proceed with a classic dialog for
credit card payments.


@section How to trigger Taler payment
The goal is to trigger a Taler payment once the customer has clicked
on the donation button. The triggering happens when the frontend requests
a @emph{contract} to the Merchant backend. According to the API
@footnote{Full specification available at @url{https://api.taler.net/}}, the backend generates contracts by
serving HTTP requests addressed to @code{/contract}. So our button's goal
is to trigger some server-side logic that will, in the end, issue a HTTP POST
to the backend's @code{/contract}.
Then, its HTML would be as follows:

@example
<form action="/donate">
  <input type="submit" value="Donate!"></input>
<form>
@end example

Namely, its work is merely invoking server-side logic.

Note that we @emph{could} have bypassed the server-side logic to request
the contract to the backend, and have requested it directly from the button's
JavaScript. However, this is highly unpractical because the backend needs
lots of information in the request's body, and we would end up hardcoding
all that information in the JavaScript.

When the server-side handler for @code{/donate} receives the form submission,
it will return a HTML page that will take care of:

@itemize
@item showing a credit card paywall to the user, if no wallet is found.
@item triggering contract generation (in JavaScript) to server-side logic.
@end itemize

A minimalistic @code{/donate} handler is shown below (in PHP):

@display
echo("fallback.html");
@end display

In practical terms, all the logic to detect the wallet in the browser and
request the contract lies in @code{fallback.html}. Moreover, the frontend
developer can get help by the @code{taler-wallet-lib.js} library, which
abstracts the signaling between the HTML page and the wallet. Let's see
below how @code{fallback.html} looks like:

@display
<html>
  <head>
    <script src="taler-wallet-lib.js" type="application/javascript"></script>
    <script type="application/javascript">

      /* This function will be called whenever the wallet signals its presence.
      It then will use the library's function taler.offerContractFrom to
      request the contract to the server-side logic. Finally, taler.offerContractFrom
      will hand the contrat to the wallet once it gets it. */
      function onWalletPresent()@{
        contract_url = "/generate-contract";
        taler.offerContractFrom(contract_url);
      @}
    /* The 'taler' object is exported by the library above */
    taler.onPresent(onWalletPresent);
    </script>
  </head>
  <body>
    <!-- Put the credit card paywall here -->
  </body>
@end display

The result is that if a wallet is found, then the contract is requested so
the user doesn't see the credit card paywall@footnote{In this simple
implementation, the user will se the paywall as long as no contract is received.
Nevertheless, it is easy to temporarily hide the paywall by using the
@code{taler.onAbsent} handler}, otherwise the page rests untouched and the
paywall remains shown.

Now, it's the server-side handler for @code{/generate-contract} that continues.
It has to generate a contract proposal about donating 1 KUDOS to the 'Taler charity program'.
This proposal will then be POSTed to the backend at @code{/contract}@footnote{We assume that
frontend and backend are reachable at the same host}. The main goal of POSTing the proposal
to the backend is to get it signed, as by design the frontend does not perform any
cryptographic work.

Let's see how @code{/generate-contract} handler should look like:

@display
...

# this variable is the JSON of a contract proposal,
# see https://api.taler.net/api-merchant.html#post--contract
# the second parameter is the transaction id
$proposal = make_contract("1 KUDOS", rand(1,10000));

# Here the frontend POSTs the proposal to the backend
$response = post_to_backend("/contract", $proposal);

if(200 != $response->status_code)@{
  manage_error($response);
  return;
@}
echo $response->body;
@end display

As said, @code{taler.offerContractFrom} will hand the contract to the wallet,
which then will prompt the user a formatted version of it.

@section How to pay via Taler

The next step for the frontend is to accept the payment from the wallet,
whenever the user accepts the contract. In Taler terminology, this action
is managed by two pages: the @emph{fulfillment} and @emph{pay} page.

The fulfillment page is in charge of implementing the following two properties:

@enumerate
@item Taler payments @emph{can} be implemented in DB-less frontends.

@item Taler payments are replayable, meaning that each purchase is associated with
a URL (the fulfillment URL) that shows the product each time it gets visited (and
of course, only the first time takes the user's money).
@end enumerate

In order to implement property (1), the frontend needs a way to recall what a contract
is about (e.g. which product, which price, the timestamp, etc.) before proceeding with
the actual payment and eventually deliver the final product.
That is achieved by @emph{reconstructing} the contract using the fulfillment page's
URL parameters@footnote{the fulfillment URL equipped with all the parameters is included
in the contract}.

In order to implement property (2), the frontend will firstly check the state to see if
the product claimed among the fulfillment URL parameter has been paid; if so, the product
is given to the customer. Otherwise, the frontend sets the payment as "pending" in the state
and @emph{executes} it in the wallet. The payment execution is performed by returning JavaScript
code from @code{taler-wallet-lib.js} that triggers the wallet to send the payment to the pay page.
Once the pay page receives the payment, it sets the state for the payment as "payed".

In this scenario, the wallet's behaviour upon payment execution is to send the payment to the pay
page and, if the payment is successful, visit again the fulfillment URL which then (thanks to the
new state set by the pay page) will return the final product.


Thus, a fulfillment URL for our example looks like the following:

@example
https://example.com/fulfillment?transaction_id=9
@end example

The @code{/fulfillment} handler will then perform the following actions:

@example
...

# At first, check if the user has already paid for the product.
# If so, deliver the product.
session_start();
if(!isset($_SESSION['payed']))@{
  # set as pending
  $_SESSION['payed'] = false;
@}
else@{
  if($_SESSION['payed'])@{
    echo "<p>Thanks!</p>";
    return;
  @}
  else@{
    echo "<p>Payment still pending</p>";
    return;
  @}
@}

# Reconstruct the contract
$rec_proposal = make_contract("1 KUDOS", $_GET['transaction_id']);
# $response obeys to the specification at: https://api.taler.net/api-merchant.html#offer
$response = post_to_backend("/contract", $rec_proposal);

# Return JavaScript that executes the contract in the wallet
echo "<html>
       <head>
        <script src="taler-wallet-lib.js"></script>
        <script>
          taler.executePayment($response['H_contract'],
                               '/frontend-pay',
                               '/donate');
        </script>
      </head>
    </html>";
@end example

The function @code{executePayment} exported by @code{taler-wallet-lib.js} will basically
hand its three parameters to the wallet which implements the following semantics:@*
check in the internal DB if @code{$response['H_contract']} has an entry, and:
@itemize
@item if that is the case, then the user accepted the contract previously and the wallet
sends a deposit permission @footnote{Roughly speaking, a deposit permission is a JSON
containing the coins to pay for a contract. Its full specification is available at:
@url{https://api.taler.net/api-merchant.html#depositpermission}} to @code{/frontend-pay}.
If this operation succeeds, then visit again the fulfillment URL, and finally enjoy
the product.
@item if not, redirect the browser to @code{/donate} (which will then reinitiate the
whole contract negotiation). This happens when the user visits a shared fulfillment URL.
The idea is to let that user buy the same products as the user who shared the fulfillment
URL. Nonetheless, the shop is not forced to follow this semantics when provides the third
parameter to @code{executePayment}.
@end itemize

By design, the wallet can send infinite times the @emph{same} deposit permission
for exactly the same contract, and get again the related product. No new coins
will be consumed starting from the second time.

The last step is the @code{/frontend-pay} handler. As said, its duty is
to receive the deposit permission from the wallet, forward it to the backend, and set
the state as "paid", if the payment is valid. See the figure below:

@example

# Check if a session exists already
session_start();
if(!isset($_SESSION['payed']))@{
  echo "<p>There is no session for this purchase. Pass through the fulfillment URL first</p>";
  return;
@}
# Get the HTTP POST body
$deposit_permission = file_get_contents('php://input');
$response = post_to_backend("/pay", $deposit_permission);
if(200 != $response->status_code)@{
  manage_error($response);  
  return;
@}
$_SESSION['payed'] = true;
return $response->body;

@end example

@section Backend configuration

@subsection Wireformat

Let's say that all the donations go to the following recipient,
expressed in @code{SEPA} format@footnote{As said, supporting SEPA is still
work in progress}.

@verbatim
{
  "type": "SEPA",
  "IBAN": "XY00 1111 2222 3333 4444 5555 6666",
  "name": "Taler charity program",
  "BIC": "XXXXAB99",
  "salt": "RANDOMSALT"
}

@end verbatim

Assume this information is stored in file @code{$DATADIR/sepa.json}.

@subsection Serving

The backend will be listening on port 9898 on the host @code{example.taler.net}

@subsection Key

The backend's key is located at @code{$DATADIR/key.priv}

@subsection Database

The backend will use a database named @code{donations} within Postgresql.

@subsection Exchange

The backend will deposit the coins it receives to the exchange at
@url{https://exchange.demo.taler.net/}, having the master key
"EXAMPLEMASTERKEY".

@subsection Final configuration

The following configuration will drive the Merchant backend to
realize what we planned in the subsections above. We assume the file
@code{$HOME/.config/taler.conf} is being edited. It is the default
file looked by the Merchant backend, but we can pass it config
files from other locations using the @code{-c} option.


@example

[merchant]
wireformat = SEPA
serve = TCP
port = 9898
currency = EUR
database = postgres

[merchant-instance-default]
KEYFILE = $DATADIR/key.priv

[merchant-instance-wireformat-default]
SEPA_RESPONSE_FILE = $DATADIR/sepa.json

[merchantdb-postgres]
config = postgres:///donations

[merchant-demoexchange]
uri = https://exchange.demo.taler.net/
master_key = EXAMPLEMASTERKEY

@end example

The sysadmin should make sure that a database named @code{donations} is
defined and accessible in the system. Once this configuration is ready,
it suffices to run the Merchant backend with:

@example
taler-merchant-httpd
@end example

If everything worked as expected, the following command:
@example
$ curl http://example.taler.net/
@end example

should return the following message:

@example
Hello, I'm a merchant's Taler backend. This HTTP server is not for humans.
@end example



@bye
